#!/usr/bin/python

from kubernetes import client, config  # noqa: F401
from openshift.dynamic import DynamicClient
from repoze.lru import lru_cache

import prometheus_client as prom
import os, requests, json, random, time


"""
  imageid format: docker-pullable://quay.io/app-sre/foo-image@sha256:87428fc522803d31065e7bce3cf03fe475096631e5e07bbd7a0fde60c4cf25c7

  expanded parse:
    uri: docker-pullable://quay.io/app-sre/foo-image
    name: foo-image
    digest: sha256
    hash: 87428fc522803d31065e7bce3cf03fe475096631e5e07bbd7a0fde60c4cf25c7
    ref: foo-image:sha256:87428fc522803d31065e7bce3cf03fe475096631e5e07bbd7a0fde60c4cf25c7
    host: quay.io
    org: app-sre
"""

NAMESPACE_SKIP = os.getenv('SKIPNS') or [ "dedicated-admin", "dedicated-reader", "default", "kube-public", "kube-system", "management-infra", "openshift", "openshift-config", "openshift-console", "openshift-infra", "openshift-logging", "openshift-metrics-server", "openshift-monitoring", "openshift-node", "openshift-operator-lifecycle-manager", "openshift-operators", "openshift-sdn", "openshift-web-console", "ops-health-monitoring" ]
NAMESPACE_TARGET = os.getenv('TARGETNS') or None 
QUAY_TOKEN = os.getenv('QUAY_TOKEN') or None
QUAY_API = os.getenv('QUAY_API') or 'https://quay.io/api/v1/'
LISTEN_PORT = int(os.getenv('LISTEN_PORT') or 8080)
POLL_INTERVAL = int(os.getenv('POLL_INTERVAL') or 30)

class VulnData:
  """This is the structure for a pod image's vulnerability data
  """
  totals = {}
  totalskeys = [ 'low', 'medium', 'high', 'unknown' ]
  status = None

class PodImage:
  """This is the structure for a pod image
  """

  uri = ""
  name = ""
  digest = ""
  hash = ""
  ref = ""
  host = ""
  org = ""
  vulndata = None

  def __init__(self, imageid):
    if imageid is None:
      raise SystemExit('Fatal: invalid imageid encountered')
    self.uri = imageid.split('@')[0]
    self.name = self.uri.split('/')[-1]
    self.digest, self.hash = imageid.split('@')[-1].split(':')
    self.ref = ''.join([self.name,":",self.digest,":",self.hash])
    self.host = ''.join(imageid.split('/')[2])
    self.org = self.uri.split('/')[-2]
    self.vulndata = VulnData()


class ClusterPodData:
  """This will query an OpenShift cluster for a list of container images
  """

  def get_pods(self, namespace=None):
    print("# Fetching pod list, namespace = %s" % ((namespace or "All Available")))
    k8s_client = config.new_client_from_config()
    dyn_client = DynamicClient(k8s_client)
    pods = dyn_client.resources.get(api_version='v1', kind='Pod')
    if namespace is None:
      pod_list = pods.get()
    else:
      pod_list = pods.get(namespace=namespace)
    return pod_list

  def get_images(self,pods):
    print("# Fetching image list from pods")
    for pod in pods.items:
      if pod.metadata.namespace in NAMESPACE_SKIP:
        continue
      for containerstatus in pod.status.containerStatuses:
        container = containerstatus.name
        if containerstatus.imageID is None:
          print("Error: no imageID present here when there should be")
          return image_list
        image = PodImage(containerstatus.imageID)
        if image.host not in image_list:
          image_list[image.host] = {}
        if image.ref not in image_list[image.host]:
          image_list[image.host][image.ref] = image
    return image_list


class QuayVulnData:
  """This will query vulnerability data from Quay.io
  """

  def query_quay(self, image):
    print("# Querying Quay for %s/%s" % (image.org, image.name))
    if QUAY_API is None:
      raise SystemExit('Fatal: QUAY_API is not set')
    stats = VulnData()
    for totalskey in stats.totalskeys:
      stats.totals[totalskey] = 0
    url = str("%srepository/%s/%s/manifest/%s%s%s/security" % (QUAY_API, image.org, image.name, image.digest, "%3A", image.hash))
    headers = {'Authorization': 'Bearer {}'.format(QUAY_TOKEN)}
    params = { 'vulnerabilities': 'true' }
#    @lru_cache(maxsize=512)
#    def lr_query_quay(url, headers, params):
#      try:
#        req = requests.get(url, headers=headers, params=params)
#        return req
#      except urllib.error.HTTPError:
#        return 'Not Found'
#
#    r = lr_query_quay(url, headers, params)

    r = requests.get(url, headers=headers, params=params)
    try:
      r.raise_for_status()
    except requests.exceptions.Timeout:
      print("Error, HTTP Timeout")
      return stats
    except requests.exceptions.HTTPError as e:
      if r.status_code == 401:
        print("Access denied (%s) attempting to to access url \"%s\"" % (r.status_code, url))
        stats.status = "access_denied"
      else:
        print(e)
        print("Error (%s) attempting to to access url \"%s\"" % (r.status_code, url))
        stats.status = "unknown"
      return stats
    try:
      rdata = r.json()
      r.connection.close()
    except ValueError:
      print("Error, unable to parse json response for url %s" % (url))
      stats.status = "unknown"
      return stats
    status = rdata["status"]
    if status == "scanned":
      stats.status = "scanned"
      if "Features" in rdata["data"]["Layer"]:
        packages = rdata["data"]["Layer"]["Features"]
        for package in packages:
          if "Vulnerabilities" in package:
            for vuln in package["Vulnerabilities"]:
              if str(vuln["Severity"]).lower() not in stats.totalskeys:
                print("Error: Quay is returning a severity string we have never seen. Skipping: %s" % (vuln["Severity"]))
              else:
                stats.totals[str(vuln["Severity"]).lower()] += 1
      else:
        stats.status = "unsupported"
    else:
      stats.status = "not_scanned"
    return stats

  def __init__(self):
    self.vulndata = VulnData()
    return None

  def get_vulndata_for(self,image):
    print("# Fetching vulnerability data for image: %s" % (image.name))

class CVDataExporter:
  """The rug that ties the room together.
  """

  def print_namespace_skip(self,namespaces=None):
    if namespaces is None:
      namespaces = "n/a"
    print("# Ignoring namespaces:  %s" % (namespaces))
  
  def print_namespace_target(self,namespace=None):
    if namespace is None:
      namespace = "All Available"
    print("# Targettting namespace: %s" % (namespace)) 

  def print_image_sources(self,image_list):
    print("# Images by source: ")
    for image_source in image_list:
      print("  %s: %d" % (image_source,len(image_list[image_source])))

  def print_images_by_source(self,image_list,image_source):
    print("# Images sourced from %s" % (image_source))
    if image_source not in image_list:
      print(" No images from that source")
    else:
      for iref in image_list[image_source]:
        print("  %s/%s/%s" % (image_source,image_list[image_source][iref].org,image_list[image_source][iref].name))
        print("    %s:%s" % (image_list[image_source][iref].digest,image_list[image_source][iref].hash))

  def get_pod_data(self):
    print("# Collecting image list")
    cluster_data = ClusterPodData()
    if NAMESPACE_TARGET is None:
      pods = cluster_data.get_pods()
    else:
      pods = cluster_data.get_pods(NAMESPACE_TARGET)
    image_list = cluster_data.get_images(pods)
    return image_list
    
  def get_vulndata_for_images(self, images, image_source="quay.io"):
    print("# Fetching vulnerability data for %s images" % (image_source))
    if image_source not in images:
      print(" No images from that source")
      return None
    for image_ref in images[image_source]:
      image = images[image_source][image_ref]
      if image_source == "quay.io":
        quay_data = QuayVulnData()
        vuln_data = quay_data.query_quay(image)
        if vuln_data:
          # print("# Status: %s, Totals: %s" % (vuln_data.status, vuln_data.totals))
          images[image_source][image_ref].vulndata = vuln_data
      else:
        print("# Unsupported image source, %s for %s" % (image_source, images[image_source][image_ref]))

  def metricify_vulndata(self, images, image_source="quay.io"):
    # BOO. ValueError: Invalid metric name: coreos_configmap-reload_e2fd60ff0ae4500a75b80ebaa30e0e7deba9ad107833e8ca53f0047c42c5a057_high
    print("# Exporting vulnerability data metrics for %s images" % (image_source))
    if image_source not in images:
      print(" No images from that source")
      return None
    for image_ref in images[image_source]:
      if images[image_source][image_ref].vulndata:
        an_image = images[image_source][image_ref]
        an_imageref = str("%s_%s_%s" % (an_image.org, an_image.name, an_image.hash))
        if an_imageref not in cvmetrics:
          cvmetrics[an_imageref] = {}
        for akey in images[image_source][image_ref].vulndata.totals:
          mname = str("%s_%s_total" % (an_imageref, akey)).replace('-','')
          mdesc = str("Current total %s class vulnerabilities for image %s" % (akey, images[image_source][image_ref].name)).replace('-','')
          if akey not in cvmetrics[an_imageref]:
            print("# Adding metric: %s" % (mname))
            cvmetrics[an_imageref][akey] = prom.Gauge(mname, mdesc)
          print("# Updating metric: %s" % (mname))
          cvmetrics[an_imageref][akey].set(images[image_source][image_ref].vulndata.totals[akey])


cvdata = CVDataExporter()
cvdata.print_namespace_skip(NAMESPACE_SKIP)
cvdata.print_namespace_target(NAMESPACE_TARGET)


if __name__ == '__main__':
  cvmetrics = {}
  image_list = {}
  prom.start_http_server(LISTEN_PORT)
  while True:
    image_list = cvdata.get_pod_data()
    cvdata.print_image_sources(image_list)
    #cvdata.print_images_by_source(image_list,"quay.io")
    vdata = cvdata.get_vulndata_for_images(image_list,"quay.io")
    vdata = cvdata.metricify_vulndata(image_list,"quay.io")

    time.sleep(POLL_INTERVAL)

#example/reference:
# Querying Quay for coreos/configmap-reload
# Status: unsupported, Totals: {'high': 0, 'unknown': 0, 'medium': 0, 'low': 0}
# Querying Quay for app-sre/aws-resource-exporter
# Status: scanned, Totals: {'high': 11, 'unknown': 0, 'medium': 21, 'low': 9}
# g = prom.Gauge('python_my_gauge', 'This is my gauge')
# g = Gauge('my_foo_value', 'This is an amazing foo')
# g.inc()
# g.dec(1)
# g.set(2.4)
